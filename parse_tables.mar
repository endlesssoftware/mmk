	.TITLE	PARSE_TABLES - TPARSE tables for MMK description file parser
	.IDENT	'V2.5'
;++
;
; FACILITY: 	    MMK
;
; ABSTRACT: 	    Parse tables for use with LIB$T(ABLE_)PARSE.
;
; MODULE DESCRIPTION:
;
;   This module contains the TPARSE parse tables and stub action
;   routines used with the PARSE_DESCRIP and PARSE_OBJECTS routines.
;
; AUTHOR:   	    M. Madison
;
; Copyright (c) 2008, Matthew Madison.
; Copyright (c) 2013, Endless Software Solutions.
; 
; All rights reserved.
; 
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 
;     * Redistributions of source code must retain the above
;       copyright notice, this list of conditions and the following
;       disclaimer.
;     * Redistributions in binary form must reproduce the above
;       copyright notice, this list of conditions and the following
;       disclaimer in the documentation and/or other materials provided
;       with the distribution.
;     * Neither the name of the copyright owner nor the names of any
;       other contributors may be used to endorse or promote products
;       derived from this software without specific prior written
;       permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
; CREATION DATE:    20-AUG-1992
;
; MODIFICATION HISTORY:
;
;   20-AUG-1992	V1.0	Madison	    Initial coding.
;   01-SEP-1992	V1.1	Madison	    Comments.
;   12-SEP-1992	V1.1-1	Madison	    Fix module=filespec parsing.
;   12-OCT-1992	V1.2	Madison	    Require blank before colon in dependency rules.
;   12-OCT-1992	V1.2-1	Madison	    Fix for blank-before-colon change.
;   08-MAR-1993	V1.2-2	Madison	    Fix library module references.
;   02-APR-1993	V1.2-3	Madison	    Support for - prefix on commands.
;   23-APR-1993	V1.3	Madison	    Improve suffix handling on object names.
;   02-JUN-1993	V1.4	Madison	    Allow "DEPENDS_ON" in place of colon.
;   04-JUN-1993	V1.5	Madison	    Add some missing directives.
;   21-AUG-1993	V1.6	Madison	    Allow missing colon for build rules.
;   17-OCT-1993 V1.6-1  Madison	    Allow blanks as library module separators.
;   19-OCT-1993	V1.6-2	Madison	    Fix "@ " and "- " in action line parsing.
;   25-OCT-1993	V1.6-3	Madison	    Fix handling of all-blank object strings.
;   15-DEC-1993	V1.6-4	Madison	    Fix "@- " and "-@ " in action line parsing.
;   08-APR-1994	V1.6-5	Madison	    Fix space-sep lists on lhs of dependencies.
;   21-JUN-1994	V1.6-6	Madison	    Fix blank before ) in libs with mod=file.
;   01-JUL-1994	V1.7	Madison	    Support for CMS.
;   06-JUL-1994	V1.7-1	Madison	    Fix .xxx.xxx<EOS> so it's accepted.
;   11-JUL-1994	V1.7-2	Madison	    Fix a couple more parsing problems.
;   12-JUL-1994	V1.8	Madison	    Fix conditionals, add :: support.
;   14-JUL-1994	V1.9	Madison	    Add prefixing on inference rules.
;   29-MAY-1996	V1.9-1	Madison	    Allow INCLUDE instead of .INCLUDE.
;   22-DEC-1996	V1.10	Madison	    Add support for rules w/must-run commands.
;   27-DEC-1998	V2.0	Madison	    Add support for IFNDEF.
;   17-JAN-2000	V2.0-1	Madison	    Fix parsing of blank-separated targets.
;   03-FEB-2000	V2.0-2	Madison	    Allow dots in symbol names.
;   05-OCT-2003 V2.0-3  Madison     Allow semicolons in target object names.
;   10-OCT-2008 V2.1	Sneddon     Added support for more recent MMS directives.
;   17-MAY-2011 V2.2    Sneddon	    Add support for '?=' and '+='.
;   07-JUL-2012 V2.3	Sneddon	    Add support for '!='.
;   28-AUG-2012 V2.3-1	Sneddon	    Allow description file lines to be empty.
;   05-MAR-2013 V2.4    Sneddon	    Add support for '~=' immediate evaluation.
;   09-APR-2013 V2.5    Sneddon	    Correct INCLUDE.
;--

	.EXTRN	PARSE_STORE
	.EXTRN	PARSE_OBJ_STORE
	.DSABL	GLOBAL

;   Determine architecture

	.NTYPE	R22TYPE,R22		; get symbol type for "R22"
R22TYPE	=	<R22TYPE@-4&^XF>-5	; type 5 = register
	.IF	EQ,R22TYPE
EVAX	=	1
BIGPAGE	=	1
ADDRESSBITS =	32
	.ENDC

; Transition codes for use with PARSE_DESCRIP.  Must match the
; corresponding codes defined in that module.

PRS_K_CHECK_COND  = 0
PRS_K_CMD_INIT	  = 1
PRS_K_SYM_INIT	  = 2
PRS_K_DEP_INIT	  = 3
PRS_K_DIR_SFX	  = 4
PRS_K_DIR_FIRST	  = 5
PRS_K_DIR_LAST	  = 6
PRS_K_RULE_INIT	  = 7
PRS_K_DIR_RHS	  = 8
PRS_K_RULE_NEWSFX = 9
PRS_K_RULE_SFX	  = 10
PRS_K_CMD_NOECHO  = 11
PRS_K_CMD_TEXT	  = 12
PRS_K_SYM2DEP	  = 13
PRS_K_SYM_VALUE	  = 14
PRS_K_DEP_TRGAPP  = 15
PRS_K_DEP_RHS	  = 16
PRS_K_RULE_END	  = 17
PRS_K_DIR_IFDEF	  = 18
PRS_K_DIR_ELSE	  = 19
PRS_K_DIR_ENDIF	  = 20
PRS_K_SYM2DEP2	  = 21
PRS_K_CMD_IGNERR  = 22
PRS_K_DIR_SILENT  = 23
PRS_K_DIR_IGNORE  = 24
PRS_K_DIR_DEFAULT = 25
PRS_K_DIR_INCLUDE = 26
PRS_K_CMD_FFORCED  = 27
PRS_K_DEP_TRGAPP2 = 28
PRS_K_DEP_DC	  = 29
PRS_K_RULE_INIPFX = 30
PRS_K_RULE_NEWPFX = 31
PRS_K_DIR_IFLHS	  = 32
PRS_K_DIR_IFEQL	  = 33
PRS_K_DIR_IFNEQ	  = 34
PRS_K_DIR_IFRHS	  = 35
PRS_K_CMD_LFORCED = 36
PRS_K_CMD_SETFLAGS = 37
PRS_K_DIR_IFNDEF  = 38
PRS_K_DIR_IFGEQ   = 39
PRS_K_DIR_IFLEQ   = 40
PRS_K_DIR_IFGTR   = 41
PRS_K_DIR_IFLSS   = 42
PRS_K_DIR_NOT     = 43
PRS_K_DIR_AND	  = 44
PRS_K_DIR_OR	  = 45
PRS_K_DIR_BUILTIN = 46
PRS_K_DIR_CASE	  = 47
PRS_K_DIR_ELSIF	  = 48
PRS_K_CHECK_GNU   = 49
PRS_K_DIR_GNU     = 50
PRS_K_SYM_DEFINED = 51
PRS_K_SYM_APPEND  = 52
PRS_K_SYM_DO	  = 53
PRS_K_SYM_EVAL    = 54

; Transition codes used with routine PARSE_OBJECTS.  Must match the
; corresponding definitions in that module.

PO_K_LIB_BEGIN	= 1
PO_K_END_OBJ	= 2
PO_K_APPNAM	= 3
PO_K_APPNAM_CMS = 4
PO_K_LIB_END	= 5
PO_K_MOD_END	= 6
PO_K_APPMOD	= 7
PO_K_APPFIL	= 8
PO_K_OBJ_INIT	= 9
PO_K_MOD_FILE	= 10
PO_K_APPGEN	= 11

; MACRO can't handle some characters as literals.

LEFTPAREN	= 40
RIGHTPAREN	= 41
LEFTANGLE	= 60
RIGHTANGLE	= 62
APOSTROPHE	= 39
COMMA		= 44
SEMI            = 59
LEFTBRACE	= 123
VERTBAR		= 124
RIGHTBRACE	= 125
TILDE		= 126

	.SBTTL	Parse_Descrip table

	$INIT_STATE PARSE_STATE, PARSE_KEY

	$STATE	COLUMN1
	$TRAN	TPA$_EOS,TPA$_EXIT
	$TRAN	!INCLUDE,TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_INCLUDE
	$TRAN	'.',DIRECTIVE
	$TRAN	!CHECK_GNU,GNU_DIR
	$TRAN	TPA$_LAMBDA,CHECK_COND

	$STATE	CHECK_COND
	$TRAN	TPA$_LAMBDA,CONTINUE,PRS_STORE,,,PRS_K_CHECK_COND

	$STATE	CHECK_GNU
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_CHECK_GNU

	$STATE	GNU_DIR
	$TRAN	'ENDIF',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_ENDIF
	$TRAN	'ELSE',GNU_ELSE
	$TRAN	TPA$_LAMBDA,GNU_IF0

	$STATE	GNU_ELSE
	$TRAN	TPA$_BLANK,GNU_ELSE
	$TRAN	TPA$_EOS,TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_ELSE
	$TRAN	TPA$_LAMBDA,GNU_ELSIF,PRS_STORE,,,PRS_K_DIR_ELSIF

	$STATE	GNU_ELSIF
	$TRAN	TPA$_BLANK,GNU_ELSIF
	$TRAN	TPA$_LAMBDA,GNU_IF0

	$STATE	GNU_IF0
	$TRAN	'IFEQ',GNU_IF1,PRS_STORE,,,PRS_K_DIR_IFEQL
	$TRAN	'IFNEQ',GNU_IF1,PRS_STORE,,,PRS_K_DIR_IFNEQ
	$TRAN	'IFDEF',IFDEF
	$TRAN	'IFNDEF',IFNDEF
	$TRAN	TPA$_LAMBDA,CHECK_COND

	$STATE	GNU_IF1
	$TRAN	TPA$_BLANK,GNU_IF1
	$TRAN	LEFTPAREN
	$TRAN	TPA$_LAMBDA

	$STATE	
	$TRAN	!STRSYM,GNU_IF2,PRS_STORE,,,PRS_K_DIR_IFLHS

	$STATE	GNU_IF2
	$TRAN	TPA$_BLANK,GNU_IF2
	$TRAN	COMMA,GNU_IF3
	$TRAN	TPA$_LAMBDA,GNU_IF3

	$STATE	GNU_IF3
	$TRAN	TPA$_BLANK,GNU_IF3
	$TRAN	!STRSYM,GNU_IF4,PRS_STORE,,,PRS_K_DIR_IFRHS

	$STATE	GNU_IF4
	$TRAN	TPA$_BLANK,GNU_IF4
	$TRAN	RIGHTPAREN,TPA$_EXIT
	$TRAN	TPA$_EOS,TPA$_EXIT

	$STATE	CONTINUE
	$TRAN	TPA$_BLANK,COMMAND,PRS_STORE,,,PRS_K_CMD_INIT
	$TRAN	!SYMBOL,SYMDEF,PRS_STORE,,,PRS_K_SYM_INIT
	$TRAN	!PATHPFX,BLDRULE0,PRS_STORE,,,PRS_K_RULE_INIPFX
	$TRAN	TPA$_LAMBDA,DEPEND,PRS_STORE,,,PRS_K_DEP_INIT

	$STATE	INCLUDE
	$TRAN	'INCLUDE',INC1
	$STATE	INC1
	$TRAN	TPA$_BLANK,INC1
	$TRAN	'=',TPA$_FAIL
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

	$STATE	DIRECTIVE
	$TRAN	'IFDEF',IFDEF
    	$TRAN	'IFNDEF',IFNDEF
	$TRAN	'ELSE',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_ELSE
	$TRAN	'ELSIF',IF0,PRS_STORE,,,PRS_K_DIR_ELSIF
	$TRAN	'ENDIF',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_ENDIF
    	$TRAN	'IF',IF0
	$TRAN	TPA$_LAMBDA,,PRS_STORE,,,PRS_K_CHECK_COND

	$STATE
	$TRAN	'SUFFIXES',DIR1,PRS_STORE,,,PRS_K_DIR_SFX
	$TRAN	'FIRST',DIR1,PRS_STORE,,,PRS_K_DIR_FIRST
	$TRAN	'LAST',DIR1,PRS_STORE,,,PRS_K_DIR_LAST
	$TRAN	'BUILTIN',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_BUILTIN
	$TRAN	'CASE_SENSITIVE',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_CASE
	$TRAN	'GNU_SYNTAX',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_GNU
	$TRAN	'SILENT',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_SILENT
	$TRAN	'IGNORE',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_IGNORE
	$TRAN	'DEFAULT',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_DEFAULT
	$TRAN	'INCLUDE',TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_INCLUDE
	$TRAN	TPA$_LAMBDA,BLDRULE,PRS_STORE,,,PRS_K_RULE_INIT

	$STATE	DIR1
	$TRAN	':',DIR2
	$TRAN	TPA$_BLANK,DIR1
	$TRAN	TPA$_EOS,DIR2
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_RHS

	$STATE	DIR2
	$TRAN	TPA$_BLANK,DIR2
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_RHS

	$STATE	IFDEF
	$TRAN	TPA$_BLANK,IFDEF
	$TRAN	!SYMBOL,TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_IFDEF

	$STATE	IFNDEF
	$TRAN	TPA$_BLANK,IFNDEF
	$TRAN	!SYMBOL,TPA$_EXIT,PRS_STORE,,,PRS_K_DIR_IFNDEF

	$STATE	IF0
	$TRAN	TPA$_BLANK,IF0
	$TRAN	'.'
	$TRAN	TPA$_LAMBDA,IF1

	$STATE	
	$TRAN	'NOT',IF1,PRS_STORE,,,PRS_K_DIR_NOT

    	$STATE	IF1
    	$TRAN	TPA$_BLANK,IF1
    	$TRAN	!STRSYM,,PRS_STORE,,,PRS_K_DIR_IFLHS

	$STATE
	$TRAN	!IF2,IF4
	$TRAN	TPA$_LAMBDA,IF4,PRS_STORE,,,PRS_K_DIR_IFRHS
	
    	$STATE	IF2
    	$TRAN	TPA$_BLANK,IF2
	$TRAN	'.'
    	$TRAN	'EQL',IF3,PRS_STORE,,,PRS_K_DIR_IFEQL
    	$TRAN	'NEQ',IF3,PRS_STORE,,,PRS_K_DIR_IFNEQ
	$TRAN   'GEQ',IF3,PRS_STORE,,,PRS_K_DIR_IFGEQ
	$TRAN   'LEQ',IF3,PRS_STORE,,,PRS_K_DIR_IFLEQ
	$TRAN   'GTR',IF3,PRS_STORE,,,PRS_K_DIR_IFGTR
	$TRAN   'LSS',IF3,PRS_STORE,,,PRS_K_DIR_IFLSS

	$STATE
	$TRAN   'EQ',IF3,PRS_STORE,,,PRS_K_DIR_IFEQL
	$TRAN   'NE',IF3,PRS_STORE,,,PRS_K_DIR_IFNEQ
	$TRAN   'GE',IF3,PRS_STORE,,,PRS_K_DIR_IFGEQ
	$TRAN   'LE',IF3,PRS_STORE,,,PRS_K_DIR_IFLEQ
	$TRAN   'GT',IF3,PRS_STORE,,,PRS_K_DIR_IFGTR
	$TRAN   'LT',IF3,PRS_STORE,,,PRS_K_DIR_IFLSS

    	$STATE	IF3
    	$TRAN	TPA$_BLANK,IF3
    	$TRAN	!STRSYM,IF4,PRS_STORE,,,PRS_K_DIR_IFRHS

	$STATE	IF4
	$TRAN	TPA$_BLANK,IF4
	$TRAN	'.'
	$TRAN	TPA$_EOS,TPA$_EXIT

	$STATE
	$TRAN	'AND',IF0,PRS_STORE,,,PRS_K_DIR_AND
	$TRAN	'OR',IF0,PRS_STORE,,,PRS_K_DIR_OR

	$STATE	BLDRULE0
	$TRAN	'.'
	$STATE	BLDRULE
	$TRAN	'.',BLDRULE,PRS_STORE,,,PRS_K_RULE_NEWSFX
	$TRAN	':',TPA$_EXIT,PRS_STORE,,,PRS_K_RULE_END
	$TRAN	'$',BLDRULE,PRS_STORE,,,PRS_K_RULE_SFX
	$TRAN	'_',BLDRULE,PRS_STORE,,,PRS_K_RULE_SFX
	$TRAN	'-',BLDRULE,PRS_STORE,,,PRS_K_RULE_SFX
    	$TRAN	TILDE,BLDRULE,PRS_STORE,,,PRS_K_RULE_SFX
	$TRAN	TPA$_EOS,TPA$_EXIT,PRS_STORE,,,PRS_K_RULE_END
	$TRAN	TPA$_BLANK,RULE1
	$TRAN	TPA$_ALPHA,BLDRULE,PRS_STORE,,,PRS_K_RULE_SFX
	$TRAN	TPA$_DIGIT,BLDRULE,PRS_STORE,,,PRS_K_RULE_SFX
	$TRAN	!PATHPFX,BLDRULE,PRS_STORE,,,PRS_K_RULE_NEWPFX

	$STATE	RULE1
	$TRAN	':',TPA$_EXIT,PRS_STORE,,,PRS_K_RULE_END
	$TRAN	TPA$_EOS,TPA$_EXIT,PRS_STORE,,,PRS_K_RULE_END
	$TRAN	TPA$_BLANK,RULE1

	$STATE	COMMAND
    	$TRAN	!CMD_PREFIXED,COMMAND,PRS_STORE,,,PRS_K_CMD_SETFLAGS
	$TRAN	TPA$_BLANK,COMMAND
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_CMD_TEXT

    	$STATE	CMD_PREFIXED
    	$TRAN	'@',CMD_PREFIXED,PRS_STORE,,,PRS_K_CMD_NOECHO
    	$TRAN	'-',CMD_PREFIXED,PRS_STORE,,,PRS_K_CMD_IGNERR
    	$TRAN	LEFTANGLE,CMD_PREFIXED,PRS_STORE,,,PRS_K_CMD_FFORCED
    	$TRAN	RIGHTANGLE,CMD_PREFIXED,PRS_STORE,,,PRS_K_CMD_LFORCED
    	$TRAN	TPA$_BLANK,TPA$_EXIT

	$STATE	SYMDEF
	$TRAN	TPA$_BLANK,SYMDEF0
	$TRAN	'=',SYMDEF1
	$TRAN	'?',SYMDEF2
	$TRAN	'+',SYMDEF3
	$TRAN	'!',SYMDEF4
	$TRAN	TILDE,SYMDEF5
    	$TRAN	COMMA,DEPEND,PRS_STORE,,,PRS_K_SYM2DEP
	$TRAN	'-',DEPEND,PRS_STORE,,,PRS_K_SYM2DEP
	$TRAN	'(',DEPEND,PRS_STORE,,,PRS_K_SYM2DEP
	$TRAN	':',DEPEND,PRS_STORE,,,PRS_K_SYM2DEP
	$TRAN	'[',DEPEND,PRS_STORE,,,PRS_K_SYM2DEP
        $TRAN   SEMI,DEPEND,PRS_STORE,,,PRS_K_SYM2DEP

	$STATE	SYMDEF0
	$TRAN	TPA$_BLANK,SYMDEF0
	$TRAN	TPA$_LAMBDA,SYMDEF0A

	$STATE	SYMDEF0A
	$TRAN	'ADDITIONALLY_DEPENDS_ON',SYMDEF0B
	$TRAN	'DEPENDS_ON',DEPEND2,PRS_STORE,,,PRS_K_SYM2DEP2
	$TRAN	'=',SYMDEF1
	$TRAN	'?',SYMDEF2
	$TRAN	'+',SYMDEF3
	$TRAN	'!',SYMDEF4
	$TRAN	TILDE,SYMDEF5
    	$TRAN	COMMA,DEPEND,PRS_STORE,,,PRS_K_SYM2DEP
	$TRAN	':',DEPEND1B,PRS_STORE,,,PRS_K_SYM2DEP2
    	$TRAN	TPA$_LAMBDA,DEPEND1,PRS_STORE,,,PRS_K_SYM2DEP2

	$STATE	SYMDEF0B
	$TRAN	TPA$_LAMBDA,DEPEND2,PRS_STORE,,,PRS_K_DEP_DC;

	$STATE	SYMDEF1
	$TRAN	TPA$_BLANK,SYMDEF1
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_SYM_VALUE

	$STATE	SYMDEF2
	$TRAN	'=',SYMDEF2A
	$STATE	SYMDEF2A
	$TRAN	TPA$_BLANK,SYMDEF2A
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_SYM_DEFINED

	$STATE	SYMDEF3
	$TRAN	'=',SYMDEF3A
	$STATE	SYMDEF3A
	$TRAN	TPA$_BLANK,SYMDEF3A
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_SYM_APPEND

	$STATE	SYMDEF4
	$TRAN	'=',SYMDEF4A
	$STATE	SYMDEF4A
	$TRAN	TPA$_BLANK,SYMDEF4A
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_SYM_DO

	$STATE	SYMDEF5
	$TRAN	'=',SYMDEF5A
	$STATE	SYMDEF5A
	$TRAN	TPA$_BLANK,SYMDEF5A
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_SYM_EVAL

	$STATE	DEPEND
	$TRAN	TPA$_BLANK,DEPEND1
	$TRAN	TPA$_EOS,TPA$_FAIL
	$TRAN	COMMA,DEPEND0,PRS_STORE,,,PRS_K_DEP_TRGAPP
	$TRAN	TPA$_ANY,DEPEND,PRS_STORE,,,PRS_K_DEP_TRGAPP

	$STATE	DEPEND0
	$TRAN	':',TPA$_FAIL
	$TRAN	COMMA,TPA$_FAIL
	$TRAN	TPA$_EOS,TPA$_FAIL
	$TRAN	TPA$_BLANK,DEPEND0
	$TRAN	TPA$_LAMBDA,DEPEND

	$STATE	DEPEND1
	$TRAN	TPA$_BLANK,DEPEND1
	$TRAN	TPA$_LAMBDA, DEPEND1A

	$STATE	DEPEND1A
	$TRAN	'ADDITIONALLY_DEPENDS_ON',DEPEND2,PRS_STORE,,,PRS_K_DEP_DC
	$TRAN	'DEPENDS_ON',DEPEND2
	$TRAN	COMMA,DEPEND0,PRS_STORE,,,PRS_K_DEP_TRGAPP
	$TRAN	':',DEPEND1B
	$TRAN	TPA$_EOS,TPA$_FAIL
	$TRAN	TPA$_ANY,DEPEND,PRS_STORE,,,PRS_K_DEP_TRGAPP2

	$STATE	DEPEND1B
	$TRAN	':',,PRS_STORE,,,PRS_K_DEP_DC
	$TRAN	TPA$_LAMBDA

	$STATE	DEPEND2
	$TRAN	TPA$_BLANK,DEPEND2
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_STORE,,,PRS_K_DEP_RHS

	$STATE	PATHPFX
	$TRAN	LEFTBRACE
	$STATE	PATHPFX1
	$TRAN	RIGHTBRACE, TPA$_EXIT
	$TRAN	TPA$_ANY, PATHPFX1

        $STATE  STRSYM
	$TRAN   TPA$_BLANK,STRSYM
	$TRAN   !QUOTED,TPA$_EXIT
	$TRAN   !SYMBOL,TPA$_EXIT
	$TRAN   TPA$_STRING,TPA$_EXIT

	$STATE	SYMBOL
	$TRAN	'$',SYMBOL1
	$TRAN	'_',SYMBOL1
	$TRAN	TPA$_ALPHA,SYMBOL1
	$STATE	SYMBOL1
	$TRAN	'$',SYMBOL1
	$TRAN	'_',SYMBOL1
	$TRAN	'.',SYMBOL1
	$TRAN	TPA$_ALPHA,SYMBOL1
	$TRAN	TPA$_DIGIT,SYMBOL1
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

	$STATE	QUOTED
	$TRAN	'"',DQUOTE
	$TRAN	APOSTROPHE,SQUOTE

	$STATE	DQUOTE
	$TRAN	'"',DQUOTE1
	$TRAN	TPA$_ANY,DQUOTE
	$STATE	DQUOTE1
	$TRAN	'"',DQUOTE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

	$STATE	SQUOTE
	$TRAN	APOSTROPHE,SQUOTE1
	$TRAN	TPA$_ANY,SQUOTE
	$STATE	SQUOTE1
	$TRAN	APOSTROPHE,SQUOTE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

	$END_STATE

	.SBTTL	Parse_Objects table

	$INIT_STATE PO_STATE, PO_KEY

	$STATE	PO_INIT
	$TRAN	TPA$_BLANK,PO_INIT
	$TRAN	TPA$_EOS,TPA$_EXIT
	$TRAN	TPA$_LAMBDA,PO_INIT1,PO_STORE,,,PO_K_OBJ_INIT

	$STATE	PO_INIT1
	$TRAN	COMMA,PO_INIT,PO_STORE,,,PO_K_END_OBJ
	$TRAN	TPA$_EOS,TPA$_EXIT,PO_STORE,,,PO_K_END_OBJ
    	$TRAN	TILDE,PO_INIT2,PO_STORE,,,PO_K_APPNAM_CMS
	$TRAN	'(',PO_LIB,PO_STORE,,,PO_K_LIB_BEGIN
	$TRAN	TPA$_BLANK,PO_ENDOBJ,PO_STORE,,,PO_K_END_OBJ
	$TRAN	TPA$_ANY,PO_INIT1,PO_STORE,,,PO_K_APPNAM

	$STATE	PO_INIT2
	$TRAN	COMMA,PO_INIT,PO_STORE,,,PO_K_END_OBJ
	$TRAN	TPA$_EOS,TPA$_EXIT,PO_STORE,,,PO_K_END_OBJ
	$TRAN	'/', PO_CMSGEN1
	$TRAN	TPA$_BLANK,PO_INIT3

	$STATE	PO_INIT3
	$TRAN	COMMA,PO_INIT,PO_STORE,,,PO_K_END_OBJ
	$TRAN	TPA$_EOS,TPA$_EXIT,PO_STORE,,,PO_K_END_OBJ
	$TRAN	'/', PO_CMSGEN1
	$TRAN	TPA$_BLANK, PO_INIT3
	$TRAN	TPA$_LAMBDA,PO_INIT,PO_STORE,,,PO_K_END_OBJ

	$STATE	PO_CMSGEN1
    	$TRAN	!GENERATION, PO_CMSGEN2
	$TRAN	TPA$_BLANK, PO_CMSGEN1

	$STATE	GENERATION
	$TRAN	'G'
	$TRAN	'g'
	$STATE
	$TRAN	'E'
	$TRAN	'e'
	$TRAN	TPA$_LAMBDA, TPA$_EXIT
	$STATE
	$TRAN	'N'
	$TRAN	'n'
	$TRAN	TPA$_LAMBDA, TPA$_EXIT
	$STATE
	$TRAN	'E'
	$TRAN	'e'
	$TRAN	TPA$_LAMBDA, TPA$_EXIT
	$STATE
	$TRAN	'R'
	$TRAN	'r'
	$TRAN	TPA$_LAMBDA, TPA$_EXIT
	$STATE
	$TRAN	'A'
	$TRAN	'a'
	$TRAN	TPA$_LAMBDA, TPA$_EXIT
	$STATE
	$TRAN	'T'
	$TRAN	't'
	$TRAN	TPA$_LAMBDA, TPA$_EXIT
	$STATE
	$TRAN	'I'
	$TRAN	'i'
	$TRAN	TPA$_LAMBDA, TPA$_EXIT
	$STATE
	$TRAN	'O'
	$TRAN	'o'
	$TRAN	TPA$_LAMBDA, TPA$_EXIT
	$STATE
	$TRAN	'N', TPA$_EXIT
	$TRAN	'n', TPA$_EXIT
	$TRAN	TPA$_LAMBDA, TPA$_EXIT

	$STATE	PO_CMSGEN2
	$TRAN	'=', PO_CMSGEN3
	$TRAN	TPA$_BLANK, PO_CMSGEN2

	$STATE	PO_CMSGEN3
	$TRAN	TPA$_BLANK, PO_CMSGEN3
	$TRAN	TPA$_ANY, PO_CMSGEN4, PO_STORE,,,PO_K_APPGEN

	$STATE	PO_CMSGEN4
	$TRAN	COMMA, PO_INIT, PO_STORE,,,PO_K_END_OBJ
	$TRAN	TPA$_EOS, TPA$_EXIT, PO_STORE,,,PO_K_END_OBJ
	$TRAN	TPA$_BLANK, PO_INIT, PO_STORE,,,PO_K_END_OBJ
	$TRAN	TPA$_ANY, PO_CMSGEN4, PO_STORE,,,PO_K_APPGEN

	$STATE	PO_ENDOBJ
	$TRAN	TPA$_BLANK,PO_ENDOBJ
	$TRAN	COMMA,PO_INIT
	$TRAN	TPA$_EOS,TPA$_EXIT
	$TRAN	TPA$_LAMBDA,PO_INIT

	$STATE	PO_LIB
	$TRAN	TPA$_BLANK,PO_LIB
	$TRAN	TPA$_LAMBDA,PO_LIB1

	$STATE	PO_LIB1
	$TRAN	'=',PO_LIBFILE,PO_STORE,,,PO_K_MOD_FILE
	$TRAN	')',PO_ENDOBJ,PO_STORE,,,PO_K_LIB_END
	$TRAN	COMMA,PO_LIB,PO_STORE,,,PO_K_MOD_END
	$TRAN	TPA$_BLANK,PO_LIB2
	$TRAN	TPA$_ANY,PO_LIB1,PO_STORE,,,PO_K_APPMOD

	$STATE	PO_LIB2
	$TRAN	'=',PO_LIBFILE,PO_STORE,,,PO_K_MOD_FILE
	$TRAN	COMMA,PO_LIB,PO_STORE,,,PO_K_MOD_END
	$TRAN	')',PO_ENDOBJ,PO_STORE,,,PO_K_LIB_END
	$TRAN	TPA$_BLANK,PO_LIB2
	$TRAN	TPA$_LAMBDA,PO_LIB1,PO_STORE,,,PO_K_MOD_END

	$STATE	PO_LIBFILE
	$TRAN	TPA$_BLANK,PO_LIBFILE
	$TRAN	TPA$_LAMBDA,PO_LIBFIL1

	$STATE	PO_LIBFIL1
	$TRAN	COMMA,PO_LIB,PO_STORE,,,PO_K_MOD_END
	$TRAN	TPA$_BLANK,PO_LIBFIL2
	$TRAN	')',PO_ENDOBJ,PO_STORE,,,PO_K_LIB_END
	$TRAN	TPA$_ANY,PO_LIBFIL1,PO_STORE,,,PO_K_APPFIL

	$STATE	PO_LIBFIL2
	$TRAN	COMMA,PO_LIB,PO_STORE,,,PO_K_MOD_END
	$TRAN	')',PO_ENDOBJ,PO_STORE,,,PO_K_LIB_END
	$TRAN	TPA$_BLANK,PO_LIBFIL2
	$TRAN	TPA$_LAMBDA,PO_LIB1,PO_STORE,,,PO_K_MOD_END

	$END_STATE

	.SBTTL	Stub routines invoked by LIB$TPARSE

	.PSECT	PRS_CODE,NOWRT,SHR,PIC,EXE
PRS_STORE:
	.IF	DF,EVAX
	.CALL_ENTRY HOME_ARGS=TRUE,MAX_ARGS=1
    	CALLG	(AP),G^PARSE_STORE
	.IFF
	.WORD	0
    	CMPB	(AP),#1
    	BEQL	10$
    	PUSHL	AP
    	CALLS	#1,G^PARSE_STORE
    	RET
10$:	CALLG	(AP),G^PARSE_STORE
	.ENDC
	RET

PO_STORE:
	.IF	DF,EVAX
	.CALL_ENTRY HOME_ARGS=TRUE,MAX_ARGS=1
	CALLG	(AP),G^PARSE_OBJ_STORE
	.IFF
	.WORD	0
    	CMPB	(AP),#1
    	BEQL	10$
    	PUSHL	AP
    	CALLS	#1,G^PARSE_OBJ_STORE
    	RET
10$:	CALLG	(AP),G^PARSE_OBJ_STORE
	.ENDC
	RET

	.END
